# Cursor Rules for imgc Project

## Project Overview
This is imgc (Universal File Processor) - a cross-platform file system watcher with an extensible plugin system. While it excels at automatic image compression, its plugin architecture allows processing any file type with custom logic.

## Core Technologies
- Python 3.8+ (main language)
- Plugin system with extensible FileProcessor base class
- Pillow (PIL) for image processing (built-in plugin)
- watchdog for file system monitoring
- PyInstaller for standalone binaries
- pytest for testing
- GitHub Actions for CI/CD

## Architecture
- main.py: CLI entry point with plugin-aware argument parsing
- imgc/plugin_api.py: Plugin base classes and argument system
- imgc/plugin_manager.py: Plugin discovery, loading, and validation
- imgc/plugin_watcher.py: File watching with plugin integration
- imgc/processor_chain.py: Plugin execution chain with timeout handling
- imgc/plugins/builtin/: Built-in processors (image compression, etc.)
- imgc/config.py: Centralized configuration defaults
- imgc/logging_config.py: Logging setup
- examples/plugins/: Example plugins for development reference

## Code Style Guidelines

### Python Code Standards
- Use type hints for all function parameters and return values
- Use pathlib.Path for all file operations (cross-platform compatibility)
- Use proper logging instead of print statements
- Handle exceptions gracefully with meaningful error messages
- Use daemon threads for background processing
- Implement timeouts for potentially long operations

### Naming Conventions
- Functions: snake_case
- Classes: PascalCase
- Constants: UPPER_SNAKE_CASE
- Environment variables: IMGC_<OPTION_NAME> (core) or IMGC_<PLUGIN>_<OPTION> (plugins)
- Plugin namespaces: lowercase with hyphens (e.g., "image", "video-processor")
- CLI arguments: --<namespace>-<option> (e.g., --image-jpeg-quality)
- File extensions: lowercase with dot (.jpg, .png, .webp, .avif)

### Error Handling
- Always log errors with context
- Use argparse.error() for CLI validation errors
- Implement graceful degradation where possible
- Provide helpful error messages to users

### Cross-Platform Considerations
- Use pathlib.Path for all path operations
- Handle Windows path separators correctly
- Consider SIGTERM availability (Windows doesn't support it)
- Use appropriate virtual environment paths (.venv/bin vs .venv/Scripts)

## Testing Requirements
- All new features must have comprehensive tests
- Test both success and failure scenarios
- Use pytest fixtures: tmp_path, monkeypatch, caplog
- Test the actual implementation, not reimplemented logic
- Extract testable functions when possible
- Use descriptive test names that explain the scenario

## Build and Release
- Makefile is the primary interface for all operations
- Use make install for dependency management
- Use make test for running tests
- Use make build for PyInstaller builds
- Use make release VERSION=vX.Y.Z for releases
- Follow semantic versioning (vX.Y.Z)

## Configuration Management
- Centralize defaults in imgc/config.py
- Support environment variables with IMGC_ prefix (core) and IMGC_<PLUGIN>_ prefix (plugins)
- Use extracted parsing functions (_env_str, _env_int, _env_float, _env_bool)
- Plugin arguments declared via PluginArgument with automatic CLI/env integration
- Document all configuration options in README.md

## Performance Guidelines
- Use threading for I/O-bound operations
- Implement file stability checking before processing
- Use cooldown periods to prevent repeated processing
- Monitor resource usage in multi-threaded scenarios
- Optimize for common use cases (watch-only mode)
- Plugin chain execution with timeout handling per processor
- Efficient plugin discovery and argument parsing

## Security Considerations
- Validate and normalize all user-provided paths
- Check file permissions before processing
- Implement resource limits and timeouts
- Sanitize all user inputs

## Documentation Standards
- Update README.md for user-facing changes
- Update CHANGELOG.md following Keep a Changelog format
- Add docstrings to all public functions
- Include type information in docstrings
- Document breaking changes prominently

## Common Patterns

### Plugin Development
```python
from imgc.plugin_api import FileProcessor, ProcessorResult, PluginArgument

class MyProcessor(FileProcessor):
    def __init__(self):
        self.quality = 80  # Default, overridden by configure_from_args
    
    @property
    def name(self):
        return "My Processor"
    
    @property
    def supported_extensions(self):
        return [".txt", ".log"]
    
    def get_plugin_arguments(self):
        return [
            PluginArgument("quality", int, 80, "Processing quality (1-100)"),
            PluginArgument("enabled", bool, True, "Enable processing")
        ]
    
    def get_plugin_namespace(self):
        return "my-proc"  # Creates --my-proc-quality, IMGC_MY_PROC_QUALITY
    
    def process(self, file_path, context):
        return ProcessorResult(success=True, message="Processed!")
```

### Environment Variable Parsing
```python
ENV_TRUE_VALUES = {'true', '1', 'yes', 'on'}

def _env_bool(name, default=False):
    value = _env_str(name, 'false' if not default else 'true').lower()
    return value in ENV_TRUE_VALUES
```

### Error Handling
```python
try:
    result = risky_operation()
except SpecificException as e:
    logger.warning('Operation failed for %s: %s', context, e)
    return None
```

### Threading
```python
stop_event = threading.Event()
bg = threading.Thread(target=worker_function, args=(data,), daemon=True)
bg.start()
```

### Path Handling
```python
path = Path(user_input).resolve()
if not path.exists():
    raise ValueError(f'Path does not exist: {path}')
```

## Anti-Patterns to Avoid
- Using os.path instead of pathlib.Path
- Silent failures without logging
- Global state or mutable globals
- Hardcoded paths or magic numbers
- Platform-specific assumptions
- Reimplementing logic in tests
- Using print() instead of logging
- Blocking operations without timeouts
- Creating plugins without proper argument declarations
- Hardcoding configuration values instead of using plugin arguments
- Ignoring plugin validation errors
- Creating multiple plugin managers when one can be reused

## File Organization
- Keep modules focused and single-purpose
- Use clear, descriptive file names
- Group related functionality together
- Separate concerns (CLI, plugin system, core logic, configuration)
- Keep test files parallel to source structure
- Plugin files should be self-contained with minimal dependencies
- Built-in plugins in imgc/plugins/builtin/, user plugins in ./plugins/
- Example plugins in examples/plugins/ for reference

## Release Process
- Update CHANGELOG.md with all changes
- Test on multiple platforms before release
- Use make release VERSION=vX.Y.Z
- Verify GitHub Actions build all platforms
- Include migration guides for breaking changes

## When Adding Dependencies
- Add to requirements.txt with version constraints
- Update PyInstaller hidden imports in Makefile if needed
- Test cross-platform compatibility
- Document any platform-specific requirements
- Consider impact on plugin system and plugin loading

## Plugin System Guidelines
- All plugins must inherit from FileProcessor base class
- Use PluginArgument for configurable parameters, not hardcoded values
- Implement proper error handling in plugin process() methods
- Use plugin namespaces to avoid argument conflicts
- Test plugins both standalone and integrated
- Document plugin arguments in help text
- Handle missing dependencies gracefully in plugins
- Use temporary files with .imgc.tmp suffix for processing
- Implement proper file validation before processing

## Debugging Guidelines
- Use appropriate log levels (debug, info, warning)
- Include context in log messages (file paths, operation details)
- Use structured logging for important events
- Implement verbose modes for troubleshooting
- Use --log-level debug to see plugin loading and execution details
- Plugin validation errors are logged with specific error messages
- Processor chain provides detailed execution statistics

## IDE and Tool Configuration
- Use .venv for virtual environments
- Run tests with make test
- Use make format for code formatting
- Follow existing code style and patterns
